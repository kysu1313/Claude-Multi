"""Session management for Claude Code instances."""

import subprocess
import os
import sys
from pathlib import Path
from typing import Optional, List
import time


class SessionManager:
    """Manages Claude Code sessions."""

    def __init__(self, config, memory_manager):
        self.config = config
        self.memory = memory_manager

    def _get_project_memory_path(self, project_path: Path) -> Path:
        r"""Get the Claude Code project memory path for a given project directory.

        Claude Code creates project directories based on the working directory path.
        Examples:
        - Windows: C:\Users\user\PROGRAMS -> C--Users-user-PROGRAMS
        - macOS: /Users/user/projects -> Users-user-projects
        - Linux: /home/user/projects -> home-user-projects
        """
        # Normalize the path
        abs_path = project_path.resolve()
        path_str = str(abs_path)

        # Platform-specific path handling
        if sys.platform == 'win32':
            # Windows: Replace drive letter colon and backslashes
            # C:\Users\user\PROGRAMS -> C--Users-user-PROGRAMS
            path_str = path_str.replace(':', '-').replace('\\', '-')
            path_str = path_str.lstrip('-')
        else:
            # Unix (macOS/Linux): Remove leading slash and replace remaining slashes
            # /Users/user/projects -> Users-user-projects
            # /home/user/projects -> home-user-projects
            path_str = path_str.lstrip('/').replace('/', '-')

        return self.config.claude_projects_dir / path_str

    def _inject_instructions(self, project_path: Path, instruction_files: Optional[List[str]] = None):
        """Inject CLAUDE.md instructions into the project directory.

        Args:
            project_path: Path to the project directory
            instruction_files: Optional list of additional instruction file paths
        """
        project_claude_md = project_path / "CLAUDE.md"

        # Collect all instruction sources
        instructions = []

        # 1. Read shared CLAUDE.md if it exists
        if self.config.shared_claude_md.exists():
            print("[>>] Loading shared instructions from ~/.claude-multi/shared/CLAUDE.md")
            with open(self.config.shared_claude_md, 'r', encoding='utf-8') as f:
                instructions.append(("Shared Instructions", f.read()))

        # 2. Read configured instruction files
        configured_files = self.config.get("instruction_files", [])
        for file_path in configured_files:
            path = Path(file_path).expanduser()
            if path.exists():
                print(f"[>>] Loading instructions from {path}")
                with open(path, 'r', encoding='utf-8') as f:
                    instructions.append((path.name, f.read()))
            else:
                print(f"[!] Warning: Instruction file not found: {path}")

        # 3. Read additional instruction files passed as arguments
        if instruction_files:
            for file_path in instruction_files:
                path = Path(file_path).expanduser()
                if path.exists():
                    print(f"[>>] Loading instructions from {path}")
                    with open(path, 'r', encoding='utf-8') as f:
                        instructions.append((path.name, f.read()))
                else:
                    print(f"[!] Warning: Instruction file not found: {path}")

        # If no instructions to inject, skip
        if not instructions:
            return

        # 4. Read existing CLAUDE.md in project (if any)
        existing_content = ""
        if project_claude_md.exists():
            with open(project_claude_md, 'r', encoding='utf-8') as f:
                existing_content = f.read()

        # 5. Merge instructions
        merged_content = self._merge_instructions(existing_content, instructions)

        # 6. Write to project CLAUDE.md
        with open(project_claude_md, 'w', encoding='utf-8') as f:
            f.write(merged_content)

        print(f"[OK] Injected instructions into {project_claude_md}")

    def _merge_instructions(self, existing: str, new_instructions: List[tuple]) -> str:
        """Merge existing CLAUDE.md with new instructions.

        Args:
            existing: Existing CLAUDE.md content
            new_instructions: List of (source_name, content) tuples

        Returns:
            Merged content
        """
        parts = []

        # Add header
        parts.append("# Claude Code Instructions")
        parts.append("")
        parts.append("This file contains instructions for Claude Code sessions.")
        parts.append("Generated by claude-multi - DO NOT EDIT MANUALLY")
        parts.append("")
        parts.append("="*60)
        parts.append("")

        # Add each instruction source
        for source_name, content in new_instructions:
            parts.append(f"## From: {source_name}")
            parts.append("")
            # Remove any existing headers from the content to avoid nesting
            cleaned_content = content.strip()
            if cleaned_content.startswith("#"):
                # Skip the first line if it's a header
                lines = cleaned_content.split('\n')
                cleaned_content = '\n'.join(lines[1:]).strip()
            parts.append(cleaned_content)
            parts.append("")
            parts.append("-"*60)
            parts.append("")

        # Add existing project-specific instructions if any
        if existing and not existing.startswith("# Claude Code Instructions"):
            parts.append("## Project-Specific Instructions")
            parts.append("")
            parts.append(existing.strip())
            parts.append("")

        return '\n'.join(parts)

    def start_session(self, project_path: Path, session_name: Optional[str] = None,
                     instruction_files: Optional[List[str]] = None) -> bool:
        """Start a Claude Code session with shared memory.

        Args:
            project_path: Path to the project directory to work in
            session_name: Optional name for this session (defaults to project name)

        Returns:
            True if session started successfully
        """
        project_path = Path(project_path).resolve()

        if not project_path.exists():
            print(f"Error: Project path does not exist: {project_path}")
            return False

        session_name = session_name or project_path.name

        # Get the Claude Code project memory path
        claude_project_path = self._get_project_memory_path(project_path)

        print(f"Session: {session_name}")
        print(f"Project: {project_path}")
        print(f"Claude Code project path: {claude_project_path}")

        # Inject CLAUDE.md instructions before starting
        if self.config.get("inject_instructions", True):
            print("\n[>>] Injecting instructions...")
            self._inject_instructions(project_path, instruction_files)

        # Sync shared memory to session before starting
        if self.config.get("sync_on_start", True):
            print("\n[>>] Syncing shared memory to session...")
            claude_project_path.mkdir(parents=True, exist_ok=True)
            self.memory.sync_to_session(claude_project_path)
            print("[OK] Memory synced to session")

        # Start Claude Code in the project directory
        print(f"\n[*] Starting Claude Code session...")
        print(f"Working directory: {project_path}")
        print("\n" + "="*60)
        print("Claude Code is running. When you exit, memory will be synced back.")
        print("="*60 + "\n")

        try:
            # Run Claude Code interactively
            # Use shell=True on Windows, False on Unix for better compatibility
            if sys.platform == 'win32':
                result = subprocess.run(
                    ["claude"],
                    cwd=str(project_path),
                    shell=True
                )
            else:
                result = subprocess.run(
                    ["claude"],
                    cwd=str(project_path)
                )

            print("\n" + "="*60)
            print("Claude Code session ended")
            print("="*60)

            # Sync memory back after session ends
            if self.config.get("sync_on_end", True):
                print("\n[<<] Syncing session memory back to shared pool...")
                self.memory.sync_from_session(claude_project_path, session_name)
                print("[OK] Memory synced from session")

            return True

        except KeyboardInterrupt:
            print("\n\n[!] Session interrupted by user")

            # Still try to sync memory
            if self.config.get("sync_on_end", True):
                print("\n[<<] Syncing session memory back to shared pool...")
                self.memory.sync_from_session(claude_project_path, session_name)
                print("[OK] Memory synced from session")

            return False
        except Exception as e:
            print(f"\n[ERROR] Error running Claude Code: {e}")
            return False

    def manual_sync(self, project_path: Path, direction: str = "both") -> bool:
        """Manually sync memory for a project.

        Args:
            project_path: Path to the project directory
            direction: "to" (shared -> session), "from" (session -> shared), or "both"

        Returns:
            True if sync was successful
        """
        project_path = Path(project_path).resolve()
        claude_project_path = self._get_project_memory_path(project_path)
        session_name = project_path.name

        if direction in ("to", "both"):
            print("[>>] Syncing shared memory to session...")
            claude_project_path.mkdir(parents=True, exist_ok=True)
            self.memory.sync_to_session(claude_project_path)
            print("[OK] Synced to session")

        if direction in ("from", "both"):
            print("[<<] Syncing session memory to shared pool...")
            self.memory.sync_from_session(claude_project_path, session_name)
            print("[OK] Synced from session")

        return True
